# You Don't Know JS Yet: Scope & Closures - 2nd Edition
# 3장: 스코프 체인<sub>Scope Chain</sub>

1장과 2장에서는 렉시컬 스코프(와 구성하는 요소)에 대해 구체적인 정의를 내리고 그 개념적인 기초에 도움이 될만한 비유를 설명했다. 이 장을 진행하기 전에, 렉시컬 스코프가 무엇이고 왜 그것이 유용한지 당신이 직접 (글이나 말로)설명해줄 다른 사람을 찾아라.

건너뛸 수도 있는 단계처럼 보이지만, 이런 생각을 시간을 들여 다른 사람들에게 설명할 수 있도록 재구성하는 것이 정말로 도움이 된다는 것을 알았다. 이런 과정은 배운 내용을 뇌가 소화하도록 도와주기 때문이다.

이제 요점을 파헤칠 시간이다. 지금부터는 좀 더 자세한 내용을 살펴볼 것이다. 그래도 위 방법을 계속 사용해 보아라. 우리가 아직 스코프<sub>scope</sub>에 대해 얼마나 모르는지를 확실히 알려줄 것이기 때문이다. 반드시 시간을 내서 글과 코드를 읽어보아라.

그림 2의 중첩 된 스코프 버블 그림을 다시 살펴보며 실행 예제의 문맥을 상기해보자.

<figure>
    <img src="images/fig2.png" width="500" alt="Colored Scope Bubbles" align="center">
    <figcaption><em>그림 2: 색깔있는 스코프 버블</em></figcaption>
    <br><br>
</figure>

또 다른 스코프의 내부로 중첩되어 있는 스코프 간의 연결을 스코프 체인이라고 하며, 이 연결을 통해서 변수에 접근할 수 있는 경로를 결정한다. 이 체인은 방향성이 있다. 위/바깥쪽으로만 룩업을 수행할 수 있기 때문이다.

## "룩업"은 (거의) 개념적이다.

그림 2에서, `for` 반복문에서 참조하는 `students` 변수의 색상에 주목하라. 우리는 어떻게 이 변수를 빨강(1) 구슬로 정확하게 결정할 수 있었을까?

2장에서 우리는 런타임에 변수에 접근하는 과정을 "룩업"이라고 설명했는데, 이 과정에서 *엔진*은 현재 스코프의 *스코프 매니저*에게 식별자/변수를 알고 있는지 물어보면서, 그 식별자/변수를 찾을 때까지 중첩된 스코프 체인을 통해 (전역 스코프를 향해) 위/바깥쪽으로 진행해야한다. 스코프 양동이안에서 일치하는 첫 번째 선언을 찾아내면 즉시 룩업이 중단된다.

마지막 빨강(1) 전역 스코프에 도달할 때까지 스코프 체인을 따라가는 동안 알맞은 변수 이름을 찾아내지 못했기 때문에, 이 룩업 과정에서 `students`가 빨강(1) 구슬이라는 것을 알 수 있다.

비슷한 방법으로 `if`조건문에 있는 `studentID`를 파랑(2) 구슬로 확정할 수 있다.

런타임 룩업 과정에 대한 이 제안은 개념적인 이해에는 효과적이지만, 실제로 이렇게 동작하지는 않는다.

구슬의 양동이 색상(변수가 비롯된 범위에 대한 메타 정보)은 초기 컴파일 과정중에 *대부분 결정*된다. 렉시컬 스코프가 이 시점에서 거의 마무리되기 때문에 구슬의 색상은 이후 런타임 도중에 발생하는 작업에 의해서는 변경되지 않을 것이다.

구슬의 색상이 컴파일에 의해 알려진 다음 바뀌지 않으므로, 이 정보는 AST에 있는 각 변수의 입력과 함께 저장될 것이다.(적어도 접근할 수 있을 것이다.) 그리고 이 정보는 프로그램의 런타임을 구성하는 실행 지침에 따라 명시적으로 사용될 것이다.

다시 말해, (2장의) *엔진*은 변수가 유래한 스코프 양동이를 알아내기 위해 여러 스코프를 룩업하는 작업이 필요하지 않다. 그 정보는 이미 알려져 있다! 런타임 룩업이 필요한 상황을 피하는 것이 바로 렉시컬 스코프의 핵심적인 최적화 장점이다.

하지만 나는 조금 전에 컴파일중에 구슬의 색상을 알아내는 것과 관련하여 "대부분 결정"된다고 말한 바 있다. 그렇다면 어떤 경우에 컴파일하는 동안에도 알아내지 *못하는* 것일까?

현재 파일(*Get Started* 1장 참조. JS 컴파일 관점에서 각 파일은 자체적으로 개별적인 프로그램임을 확실히 하고있다.)에서 어휘적으로 사용 가능한 스코프 어디에도 선언되지 않은 변수에 대한 참조를 생각해보라. 선언을 찾지 못했더라도 *반드시* 에러인 것은 아니다. 런타임 상태인 다른 파일(프로그램)이 공유하는 전역변수에 대신 선언했을지도 모른다.

그래서 그 변수가 접근 가능한 양동이에 적절하게 선언되었는지에 대한 여부의 최종 결정은 런타임까지 연기해야 할 수도 있다.

초기에 *선언되지 않은* 변수에 대한 참조는 컴파일되는 동안 색이 없는 구슬로 남게 된다. 이 구슬의 색상은 관련된 다른 파일이 컴파일되고 그 프로그램의 런타임 상태가 시작될때까지 정해질 수 없다. 이렇게 미뤄진 룩업은 결국 변수가 발견된 스코프(아마도 전역 스코프)의 색상으로 결정할 것이다.

하지만, 이 룩업은 변수당 최대 한 번만 필요하다. 런타임중에 벌어지는 어떤 상황도 뒤늦게 구슬의 색상을 바꿀 수는 없기 때문이다.

2장의 "룩업 실패" 섹션은 참조가 실행되는 순간까지도 여전히 구슬에 색이 없는 경우에 어떤 일이 일어나는지를 다루고 있다.

## 섀도잉<sub>Shadowing</sub>

"섀도잉"은 신비롭고 약간 모호하게 들릴 수 있다. 하지만 걱정하지 마라. 완전히 맞는 말이다!

이 장의 실행 예제에서는 스코프의 경계에 걸쳐 서로 다른 변수명을 사용한다. 모두 고유한 이름을 갖고 있기 때문에, 어떻게 보면 모든 변수를 하나의 (빨강(1)같은)양동이에 넣어도 문제가 없을 것 같다.

서로 다른 렉시컬 스코프 양동이를 갖는 것이 더 중요해지는 순간은 각각 다른 스코프에서 어휘적으로 동일한 이름을 가진 변수를 2개 이상 갖기 시작했을 때이다. 하나의 스코프에서는 같은 이름의 변수를 두 개 이상 가질 수 없다. 이런 다중 참조는 하나의 변수로 가정할 것이다.

그래서 동일한 이름의 변수를 두 개 이상 유지해야 한다면, 별도의 (가끔씩 중첩된)스코프를 이용해야만 한다. 그리고 이 경우 다른 스코프 양동이가 배치되는 방법과 매우 관련이 있다.

아래를 자세히 보자:

```js
var studentName = "Suzy";

function printStudent(studentName) {
    studentName = studentName.toUpperCase();
    console.log(studentName);
}

printStudent("Frank");
// FRANK

printStudent(studentName);
// SUZY

console.log(studentName);
// Suzy
```

| 팁: |
| :--- |
| 넘어가기 전에, 이 책에서 다룬 다양한 기법과 비유로 잠시 위 코드를 분석하라. 특히 이 코드에서 구슬과 버블을 확실히 구분하라. 좋은 연습이 될 것이다. |

1행의 `studentName` 변수(`var studentName = ..` 구문)는  빨강(1) 구슬을 생성한다. 함수 `printStudent(..)` 정의에 같은 이름의 변수가 3행에 파란(2)구슬로 선언 되어 있다.

`studentName = studentName.toUpperCase()` 할당 구문과 `console.log(studentName)` 구문에서 `studentName` 은 어떤 색상의 구슬일까? 세 개의 `studentName` 참조 모두는 파랑(2)일 것이다.

"룩업"이라는 개념을 이용해, 현재 스코프부터 출발해서 위/바깥쪽으로 이동하면서 알맞은 변수가 나올 때 중지하면 된다고 앞서 이야기했다. 위 구문에서는 파랑(2) `studentName`을 바로 찾을 수 있으므로 빨강(1) `studentName`는 고려하지 않아도 된다.

이것이 "섀도잉"이라고 부르는 렉시컬 스코프 동작의 핵심이다. 파랑(2) `studentName` (매개)변수가 빨강 `studentName`을 가리고 있다. 그래서 이 매개 변수가 전역 변수를 '섀도잉'한다고 볼 수 있다. 위 문장을 스스로 반복해 읽으면서 용어를 제대로 이해했는지 확인하라.

그래서 `studentName`에 새 값을 할당하더라도 전역의 빨강(1) `studentName`이 아닌 파랑(2) `studentName`에만 영향을 준다.

외부 스코프로부터 내부 변수를 섀도잉할 때 발생하는 한 가지 직접적인 영향은 (중첩된 스코프를 통한) 안/아래쪽 스코프에서는 어떤 구슬이라도 섀도잉으로 가려진 변수(이 경우, 빨강(1))의 색상으로 색칠할 수 없다는 것이다. 다시 말해, 모든 `studentName` 식별자 참조는 매개변수 `studentName`과 일치하겠지만, 전역변수 `studentName`과는 일치하지 않을 것이다. `printStudent(..)` 함수 (또는 중첩된 스코프 내부에 있는) 어떤 것이라도 전역의 `studentName`을 참조하는 것은 어휘적으로 불가능하다. 

### 전역 섀도잉을 무시하는 방법

주의하라: 이제부터 설명할 기법은 그다지 유용하지 않고 코드를 읽는 사람에게 혼란을 줄 수도 있으며 프로그램에 버그를 발생시킬 수도 있기 때문에 그다지 좋은 방법이 아니다. 단지 당신이 실제 프로그램에서 이런 동작을 우연히 발견할 수도 있고, 어떤 일이 벌어지는지를 이해하는 것이 실수를 방지하기 위해 필요하기 때문에 이 기법을 다루는 것이다. 

섀도잉으로 가려진 변수가 있는 스코프에서 전역 변수에 접근할 수는 *있다.* 하지만, 일반적인 어휘적 식별자 참조로 접근하는 것은 아니다.

전역 스코프(빨강(1))에서 `var` 선언과 `function` 선언 또한 *전역 객체*(—기본적으로 전역 스코프를 나타내는 객체를 표현)의 (식별자와 동일한 이름의)속성으로 그들 자신을 나타낸다. 만약 당신이 브라우저 환경에서 JS를 작성했다면 전역 객체는 `window`로 인식하게 될 것이다. *완전히* 정확한 말은 아니지만, 논의하기에는 충분하다. 다음 장에서 전역 스코프/객체에 대해 더 알아볼 것이다.

이 프로그램을 자세히 살펴보자. 특별히 브라우저 환경에서 독립적으로 실행되고 있다.

```js
var studentName = "Suzy";

function printStudent(studentName) {
    console.log(studentName);
    console.log(window.studentName);
}

printStudent("Frank");
// "Frank"
// "Suzy"
```

`window.studentName` 참조가 보이는가?  이 표현식은 전역 변수 `studentName`를 (지금은 전역 객체와 같은 척 하고 있는)`window`의 속성으로 접근하고 있다. 이것이 섀도잉한 변수가 있는 스코프 내부에서 섀도잉으로 가린 변수에 접근할 수 있는 유일한 방법이다.

 `window.studentName`는 별도의 스냅샷 사본이 아니라 전역 `studentName` 변수의 거울이다. 한 쪽에 변화가 생기면 다른 쪽에서도 같은 변화를 볼 수 있다. 어느쪽이든 마찬가지이다. `window.studentName`를 실제 `studentName` 변수에 접근하는 getter/setter로 생각할 수도 있다. 사실은, 전역 객체에 속성을 생성하거나 설정하여 전역 스코프에 변수를 *추가*할 수도 있다.

| 주의: |
| :--- |
| 기억하라: 단지 *할 수 있다*는 것은 *해야 한다*는 의미가 아니다. 접근해야 하는 전역 변수는 섀도잉하지 말아야 하고, 반대로 이미 섀도잉으로 가린 전역 변수에 접근하기 위해 이 방법을 사용하지도 말아야 한다. 그리고 일반적인 선언문이 아니라 `window`의 속성을 이용해 전역 변수를 만들어서 코드를 읽는 사람들을 절대로 혼란스럽게 하지 말아라! |

이 작은 "속임수"는 (중첩된 스코프에서 섀도잉으로 가려진 변수가 아니라)전역 스코프의 변수에 접근할 때에만 사용할 수 있고, `var` 또는 `function`으로 선언된 변수이어야만 한다.

전역 스코프에서 한 선언의 또 다른 형태는 전역 객체에 속성을 생성하지 않는다.

```js
var one = 1;
let notOne = 2;
const notTwo = 3;
class notThree {}

console.log(window.one);       // 1
console.log(window.notOne);    // undefined
console.log(window.notTwo);    // undefined
console.log(window.notThree);  // undefined
```

전역 스코프가 아닌 다른 스코프에 있는 변수는 어떤 형태로 선언을 하더라도 섀도잉을 사용한 스코프에서 절대로 접근할 수 없습니다.

```js
var special = 42;

function lookingFor(special) {
    // 이 스코프 내부의 `special` (매개변수)식별자는
    // keepLooking() 내부에서 섀도잉으로 가려진다.
    // 그래서 해당 스코프에서는 접근할 수 없다.

    function keepLooking() {
        var special = 3.141592;
        console.log(special);
        console.log(window.special);
    }

    keepLooking();
}

lookingFor(112358132134);
// 3.141592
// 42
```

전역의 빨강(1) `special` 변수는 파랑(2) `special` 변수의 섀도잉으로 가려지고, 파랑(2) `special` 자신도 `keepLooking()` 내부의 초록(3) `special`의 섀도잉으로 가려지게 된다. 간접적인 참조 `window.special`를 사용하면, 여전히 빨강(1) `special`에 접근할 수 있다. 그러나 `keepLooking()`에서 번호 `112358132134`를 갖고 있는 파랑(2) `special`에는 접근할 수 있는 방법이 없다.

### 복사해놓은 것은 접근한 것이 아니다

"그런데, 이런 경우는...?" 이라는 질문을 수도 없이 받았다.  다음을 자세히 보자:

```js
var special = 42;

function lookingFor(special) {
    var another = {
        special: special
    };

    function keepLooking() {
        var special = 3.141592;
        console.log(special);
        console.log(another.special);  // 아주 교묘하다!
        console.log(window.special);
    }

    keepLooking();
}

lookingFor(112358132134);
// 3.141592
// 112358132134
// 42
```

앗! 그렇다면 `another` 객체 기법은 `special` 매개변수가 `keepLooking()`내부에서는 "절대로 접근할 수 없다"는 위 주장을 반증하는 것일까? 아니다. 위 주장은 아직도 틀리지 않다.

`special: special`은 `special` 매개변수의 값을 다른 컨테이너에 (같은 이름의 속성으로) 복사한 것이다. 당연히 이 값을 다른 컨테이너에 붙여 넣으면 (`another`도 섀도잉하지 않는 이상) 섀도잉이 적용되지 않는다. 하지만 그렇다고 해서 `special` 매개변수에 접근했다는 것을 의미하진 않는다. 이것은 `another` 컨테이너의 형태(객체의 속성)로 복사한 값에 접근했다는 것을 의미한다. 여전히 `keepLooking()` 내부에서 파랑(2) `special` 매개변수에 다른 값을 할당할 수는 없다.

다음과 같은 상황을 들며 "그런데, 이런 경우는...?"라고 말해볼 수 있다: `112358132134` 같은 수 타입 값이 아니라 배열이나 객체를 대신 사용했다면 어떨까? 원시 값의 복사본 대신 객체에 대한 참조 값이 있으면 접근 불가한 값을 "수정"할 수 도 있지 않을까?

안된다. 참조를 통해 객체 값의 내용을 변조하는 것은 어휘적으로 변수 자체에 접근하는 것이 *아니다.* 여전히 파랑(2) `special` 매개변수에 다른 값을 할당할 수는 없다.

### 잘못된 섀도잉

선언으로 섀도잉을 할 때, 모든 선언의 조합이 허용되는 것은 아니다. `let`은 `var`를 섀도잉 할 수 있지만, `var`는 `let`을 섀도잉할 수 없다:

```js
function something() {
    var special = "JavaScript";

    {
        let special = 42;   // 제대로 된 섀도잉

        // ..
    }
}

function another() {
    // ..

    {
        let special = "JavaScript";

        {
            var special = "JavaScript";
            // ^^^ Syntax Error

            // ..
        }
    }
}
```

`another()`함수를 보면, 안쪽에 있는 `var special` 선언이 함수 전체의 `special`을 선언하려고 시도하며, (`something()`함수에서 했던 것처럼)그 자체로는 괜찮다.

이 경우 syntax error의 설명은 `special`이 이미 정의되어 있다고 나오는데, 이 에러 메시지는 약간 오해의 소지가 있다. 일반적으로 섀도잉을 허용하기 때문에 `something()`에서는 일어나지 않는 일이기 때문이다.

`SyntaxError`가 발생하는 진짜 이유는 기본적으로 `var`가 동일한 이름으로 한 `let` 선언의 "경계를 넘어 가려고" (또는 뛰어 넘으려고) 시도하기 때문이다. 이런 경우는 허용되지 않는다.

경계를 넘어가면 안된다는 규칙이 각 함수의 경계를 확실히 지키고 있으므로, 아래와 같은 경우에도 예외없이 적용할 수 있다.:

```js
function another() {
    // ..

    {
        let special = "JavaScript";

        ajax("https://some.url",function callback(){
            // 제대로 된 섀도잉
            var special = "JavaScript";

            // ..
        });
    }
}
```

요약: (내부 스코프의) `let`은 언제나 외부 스코프의 `var`를 섀도잉 할 수 있다. (내부 스코프의) `var`는 함수 경계가 사이에 있을 때만 외부 스코프의 `let`을 섀도잉 할 수 있다.

## 함수 이름 스코프

지금 본 것처럼 `function` 선언은 이렇게 한다:

```js
function askQuestion() {
    // ..
}
```

그리고 1장과 2장에서 다룬 것처럼, 이런 `function` 선언은 선언이 된 스코프 안에 (위의 경우, 전역 스코프에서)  `askQuestion`이라는 식별자를 생성할 것이다.

이 프로그램은 어떨까?

```js
var askQuestion = function(){
    // ..
};
```

`askQuestion` 변수가 생성된다는 점은 동일하다. 하지만, 독립적인 선언이 아니라 값으로 사용할 함수를 정의하는 `function` 선언이므로 함수 자체가 "호이스팅"되지 않을 것이다.(5장 참고)

`function` 선언과 `function` 표현식의 한 가지 주요 차이점은 함수의 이름 식별자에 어떤 일이 발생하는지이다. 이름이 있는 `function` 표현식을 보자.

```js
var askQuestion = function ofTheTeacher(){
    // ..
};
```

우리는 `askQuestion`가 외부 스코프에 머무른다는 것을 알고 있다. 하지만 `ofTheTeacher` 식별자는 어떨까? 공식적인 `function` 선언의 경우, 이름 식별자는 외부/둘러싸는 스코프에 포함되고, 이렇게 가정하는 것이 합리적일 수 있다. 하지만 `ofTheTeacher`는 **함수 자체의 내부**에서 식별자로 선언되었다.

```js
var askQuestion = function ofTheTeacher() {
    console.log(ofTheTeacher);
};

askQuestion();
// function ofTheTeacher()...

console.log(ofTheTeacher);
// ReferenceError: ofTheTeacher is not defined
```

| 비고: |
| :--- |
| 사실, `ofTheTeacher`가 정확하게 *함수 스코프의 내부*에 있는 것은 아니다. 부록 A, "암시적 스코프"에서 자세히 설명할 것이다. |

`ofTheTeacher`는 외부가 아닌 함수 내부에서 선언되기만 할 뿐만이 아니라 수정할 수 없는 변수로도 정의된다:

```js
var askQuestion = function ofTheTeacher() {
    "use strict";
    ofTheTeacher = 42;   // TypeError

    //..
};

askQuestion();
// TypeError
```

엄격 모드를 적용했기 때문에, 값을 할당하는 데에 실패한 오류가 `TypeError`로 나온 것이다. 엄격 모드를 사용하지 않으면, 아무런 예외 없이 조용히 할당이 실패한다.

`function` 표현식에 이름 식별자가 없으면 어떻게 될까?

```js
var askQuestion = function(){
   // ..
};
```

이름 식별자가 있는 `function` 표현식은 "기명 함수 표현식"이라 하고, 이름 식별자가 없는 것은 "익명 함수 표현식"이라고 한다. 익명 함수 표현식은 두 스코프에 영향을 주는 이름 식별자가 명확하게 없다.

| 비고: |
| :--- |
| 기명 vs 익명 `function` 표현식에 대해, 부록 A에서는 위의 두 표현식 중 어떤 것을 사용할지 결정하는데 영향을 미치는 요인을 포함한 내용으로 훨씬 더 자세히 알아볼 것이다. |

## 화살표 함수

ES6에서 "화살표 함수"라고 하는 추가적인 `function` 표현식이 언어에 추가되었다.
 added an additional `function` expression form to the language, called "arrow functions":

```js
var askQuestion = () => {
    // ..
};
```

화살표 함수 `=>`는 `function`이라는 단어를 사용해서 정의하지 않아도 된다. 또한, 매개변수를 감싸는 `( .. )`도 어떤 간단한 상황에서 생략할 수 있다. 마찬가지로, 함수의 몸체를 감싸는 `{ .. }`도 특정한 경우에는 생략할 수 있다. 그리고 `{ .. }`를 생략하면 반환 값을 `return` 키워드 없이 내보낼 수 있다.

| 비고: |
| :--- |
| 화살표 함수 `=>`의 매력은 보통 "간결한 구문"으로 알려져 있고, 객관적으로 더 읽기 쉬운 코드와 동일하다는 주장도 있다. 하지만, 이런 주장은 아무리 해도 확실한 것이 아니고, 완전히 잘못 파악한 결과라고 생각한다. 부록 A에서 다양한 함수 형태의 "가독성"에 대해 파헤쳐볼 것이다. |

화살표 함수는 어휘적으로 익명이다. 함수를 참조하는 직접적인 식별자가 없음을 의미한다. `askQuestion`에 할당하면 "askQuestion"이라는 이름을 유추하여 생성하긴 하지만, **익명이 아닐 때와 동일하지는 않다.**

```js
var askQuestion = () => {
    // ..
};

askQuestion.name;   // askQuestion
```

화살표 함수는 다양한 형태/조건에 대한 많은 변형을 머릿속으로 굴려봐야 할 필요성을 댓가로 구문의 간결함을 달성한다. 몇 가지 예를 들면 다음과 같다:

```js
() => 42;

id => id.toUpperCase();

(id,name) => ({ id, name });

(...args) => {
    return args[args.length - 1];
};
```

화살표 함수를 언급하게 된 진짜 이유는 화살표 함수가 `function`으로 선언한 함수와는 렉시컬 스코프에 대한 부분이 어떻게든 다르게 동작한다고 하는 흔하지만 잘못된 주장 때문이다.

이 주장은 잘못되었다.

익명이라는 점(그리고 선언적인 형태가 없는 것)을 제외하고, 화살표 함수 `=>` 는 `function` 함수와 같은 동일한 렉시컬 스코프 규칙을 갖는다. 화살표 함수는 몸체에 `{ .. }`가 있든 분리되고 내부 중첩된 스코프의 양동이를 생성한다. 이 중첩된 스코프 양동이 내에 선언한 변수는 `function` 스코프에서와 동일하게 작동한다.

## 마무리

함수(선언이나 표현식)가 정의되면 새 스코프가 생성된다. 내부에서 서로 중첩된 스코프의 위치는 프로그램 전체에서 자연스러운 스코프 계층 구조를 형성한다. 이를 스코프 체인이라 한다. 스코프 체인은 위/바깥쪽 방향의 변수에 접근하는 것을 제어한다.

각각의 새 스코프는 자체 변수 세트를 저장할 수 있는 공간으로 깨끗한 슬레이트를 제공한다. 스코프 체인의 다른 수준에서 변수명이 중복되면, 섀도잉이 발생하고, 해당하는 내부 지점에서 외부의 변수에 접근하는 것을 차단합니다.

지금까지 다루었던 세부 사항을 마무리하고, 다음 장에선 모든 JS 프로그램이 갖고 있는 주요 스코프(전역 스코프)로 초점을 옮길 것이다.
