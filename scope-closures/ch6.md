# You Don't Know JS Yet: Scope & Closures - 2nd Edition
# Chapter 6: 스코프 노출을 제한하기

지금까지 스코프와 변수가 어떻게 작동하는지 그 동작 방식을 설명하는 것에 집중했다. 이러한 기초 지식이 확고히 자리 잡으면서 우리의 관점은 프로그램 전체에 적용되는 결정과 패턴까지 확장되며, 이전보다 높은 수준으로 상승하게 된다.

먼저, 프로그램 변수를 스코프의 과다한 노출을 줄이는 방식으로 조직하기 위해 다른 스코프 레벨(함수와 블록)을 사용해야 하는 이유와 방법에 대해 알아볼 것이다.

## 노출의 최소화

함수가 자체 스코프를 정의하다는 것은 이해가 될 것이다. 하지만, 스코프를 생성하기 위해 다시 블록이 필요한 이유는 무엇일까?

소프트웨어 엔지니어링에서는 일반적으로 소프트웨어 보안에 적용되는 기본 원칙으로 "최소 권한 원칙<sub>The Principle of Least Privilege</sub>"(POLP). [^POLP]을 명시하고 있다. 그리고 현재 논의하고 있는 것에 적용되는 이 원칙의 변형으로 흔히 "최소 노출<sub>Least Exposure</sub"(POLE)이란 것이 있다.

POLP는 소프트웨어 아키텍처에 대한 방어태새를 나타낸다. 시스템의 구성 요소는 최소 권한, 최소 접근, 최소 노출로 작동하도록 설계되어야 한다. 각 부분이 최소한의 필요 기능으로 연결되어 있어야 하나의 부분이 손상되거나 실패하더라도 시스템의 나머지 부분에 미치는 영향이 최소화되기 때문에 보안 측면에서 전체 시스템이 더 강력해진다.

POLP가 시스템 수준의 구성요소 설계에 초점을 맞춘다면 *POLE*은 더 낮은 수준에 초점을 맞춘다. 여기서는 스코프가 서로 상호 작용하는 방식에 적용할 것이다.

다음 POLE에서 노출을 최소화하려는 것은 무엇일까? 단순히 각 스코프에 등록된 변수이다.

이렇게 생각해보자. 프로그램의 모든 변수를 전역 스코프에 배치한다면 어떨까? 당장은 나쁜 아이디어라고 느껴지겠지만, 왜 그런지 생각해 볼 필요가 있다. 프로그램의 한 부분에서 사용하는 변수가 스코프를 통해 프로그램의 다른 부분에 노출되는 경우 다음과 같은 세 가지 주요 위험이 발생한다.

* **네이밍 충돌**: 프로그램의 서로 다른 두 부분에서 공통적이고 유용한 변수/함수 이름을 사용하지만 식별자가 하나의 (전역 스코프처럼) 공유된 스코프에서 온 경우 이름 충돌이 발생한다. 이런 경우, 다른 부분의 코드에서 예상하지 못한 방식으로 변수/함수를 사용할 때 버그가 발생하기 쉽다.

    예를 들어, 모든 반복문에서 하나의 전역 변수의 이름으로 'i'를 사용했을때, 어떤 함수에서 반복문 내부를 반복하는 동안 다른 함수의 반복문이 실행되어 공유된 'i' 변수가 예기치 않은 값을 얻게 될 것을 생각해보라.

* **예상치 않은 동작**: 용도가 *프라이빗*한 변수/함수를 프로그램의 일부에 노출하면 다른 개발자가 의도하지 않은 방식으로 사용할 수 있으므로 예상된 동작을 위반하고 버그를 발생시킬 수 있다.

    예를 들어, 당신의 프로그램 한 부분은 어떤 배열이 숫자만 포함되어 있을것으로 추정하고 있었는데 다른 사용자의 코드는 그 배열이 참/거짓 값과 문자열을 포함하도록 수정할 수 있다. 이 경우, 예기치 않은 방식으로 코드가 잘못 동작할 수 있다.

    게다가 *프라이빗*한 세부 정보가 노출되면 의도하지 않은 사용자가 당신이 도입한 제약 사항을 침범하려 시도하게 되고 소프트웨어 내부의 허용되지 않는 부분을 사용해 작업을 수행할 것이다.

* **의도하지 않은 종속성**: 변수/함수를 불필요하게 노출하면 다른 개발자가 *프라이빗*한 부분을 사용하고 의존하게 된다. 지금 바로 프로그램이 중단되는 것은 아니지만 향후 리팩토링 위험을 발생시킨다. 왜냐하면 이제 제어하지 않는 소프트웨어의 일부를 잠재적으로 손상시키지 않고서 변수나 기능을 쉽게 리팩토링할 수 없기 때문이다.

    예를 들어, 숫자 배열에 의존하는 코드를 사용하다가 배열 대신 다른 데이터 구조를 사용하는 것이 낫다고 판단한 경우, 이제 당신은 소프트웨어에서 영향받는 다른 부분을 조정할 책임을 져야 한다.

POLE은 변수/함수 스코프 지정에 적용하는 것으로 기본적으로 필요한 최소한의 노출을 기본 설정하며 다른 모든 것은 최대한 비공개로 유지한다. 또한 모든 항목을 전역(또는 외부 함수) 스코프에 배치하지 말고 가능한 작고 깊게 중첩된 스코프에서 변수를 선언한다.

위의 조언대로 소프트웨어를 설계할 경우 이러한 세 가지 위험을 피할(적어도 최소화할) 수 있는 가능성이 훨씬 커진다.

다음 코드를 살펴보자:

```js
function diff(x,y) {
    if (x > y) {
        let tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}

diff(3,7);      // 4
diff(7,5);      // 2
```

위의 'diff(..)' 함수에서 우리는 'y'가 'x'보다 크거나 같도록 하여 ('y - x') 뺄 때 결과가 '0' 이상이 되도록 하고자 한다. 처음에 'x'가 더 크면(결과는 음수가 된다!), 'tmp' 변수를 사용해서 'x'와 'y'를 교환하고 결과를 양수로 유지한다.

위 단순한 예시에서, `tmp`가 `if` 블록 안에 있는지, 함수 스코프에 속하는지 여부는 중요하지 않아 보인다. 물론 전역 변수가 되어서는 안 됩니다! 그러나 POLE 원칙에 따라 `tmp`는 가능한한 스코프 내부에 숨겨야한다. 그래서 (`let`을 사용하여) `tmp`의 스코프를`if` 블록까지로 차단한다.

## 평범한(함수) 스코프에 숨기기

이제, 변수와 함수 선언을 가능한 가장 (깊게 중첩된) 아래의 스코프로 숨기는 것이 중요한 이유를 확실히 알게 되었다. 그러나 이것은 어떻게 하는 것일까?

이미 블록 스코프의 선언문인 `let`과 `const` 키워드를 다루었고, 조만간 다시 자세히 살펴보겠다. 그 전에 먼저 `var`나 `function` 선언을 스코프 내부에 숨기는 것은 어떨까? 선언문을 `function` 스코프로 감싸서 쉽게 숨길 수 있다.

`function` 스코프 지정이 유용할 수 있는 예를 들어보자.

수학 연산자인 "팩토리얼"("6!"으로 표기)은 주어진 정수부터 `1`까지 내려가며 연속으로 곱한 값이다. 사실 `1`을 곱하는 것은 의미가 없으므로 `2`에서 멈출 수 있다. 즉, "6!"은 "6 * 5!"와 같고 "6 * 5 * 4!" 등과 같다. 관련된 수학적 특성 때문에, 주어진 정수의 팩토리얼(예: "4!") 값은 달라지지 않으므로 한 번만 계산하고 다시 계산할 필요가 없다.

따라서 아무런 계획 없이 `6`에 대한 팩토리얼을 계산한 다음 `7`에 대한 팩토리얼을 계산한다면 2에서 6까지 모든 정수의 팩토리얼을 불필요하게 다시 계산할 수도 있다. 만약 메모리와 속도를 교환할 의향이 있다면 계산 시 각 정수의 팩토리얼을 캐싱하여 불필요한 연산을 아낄 수 있다.

```js
var cache = {};

function factorial(x) {
    if (x < 2) return 1;
    if (!(x in cache)) {
        cache[x] = x * factorial(x - 1);
    }
    return cache[x];
}

factorial(6);
// 720

cache;
// {
//     "2": 2,
//     "3": 6,
//     "4": 24,
//     "5": 120,
//     "6": 720
// }

factorial(7);
// 5040
```

위 코드에서는 계산한 팩토리얼 값을 `cache`에 저장하여 여러 번 `factorial(...)`을 호출하더라도 이전에 계산한 값을 유지하도록 한다. 하지만 `cache` 변수는 `factorial(..)` 동작 방식에 관련된 상당히 *프라이빗*한 세부사항으로, 특히 글로벌 스코프에는 노출하지 말아야 하는 요소이다.

| 비고: |
| :--- |
| 이 `factorial(..)`은 내부에서 자신을 다시 호출하기 때문에 재귀적인데, 코드를 단지 간결하게 하기 위함이었다. 재귀적이지 않게 구현하더라도 `cache`와 관련된 스코프에 대한 분석은 동일할 것이다. |

그러나 이러한 과노출 문제를 해결하는 것은 `cache` 변수를 `factorial(..)` 안에 숨기는 것만으로 끝나지 않는다. 여러번 호출하더라도 `cache`를 유지해야 하므로 해당 함수의 바깥 스코프에 두어야 한다. 그렇다면 이 문제를 어떻게 해결할 수 있을까?

`cache`가 위치할 다른 중간 스코프(외부/전역 스코프와 `factorial(..)`의 내부 사이)를 정의하자.

```js
// 외부/전역 스코프

function hideTheCache() {
    // `cache`를 숨길 "중간 스코프"
    var cache = {};

    return factorial;

    // **********************

    function factorial(x) {
        // 내부 스코프
        if (x < 2) return 1;
        if (!(x in cache)) {
            cache[x] = x * factorial(x - 1);
        }
        return cache[x];
    }
}

var factorial = hideTheCache();

factorial(6);
// 720

factorial(7);
// 5040
```

`hideTheCache()` 함수는 `factorial(..)`을 여러 번 호출하더라도 `cache`가 값을 유지할 수 있도록 하는 스코프를 만드는 것 외에 다른 목적이 없다. 그러나 `factorial(..)`이 `cache`에 접근하기 위해서는 같은 스코프 내부에 `factorial(..)`을 정의해야 한다. 그 다음엔 함수 참조를 `hideTheCache()`의 값으로 반환하고 `factorial`이라는 외부 스코프 변수에 저장한다. 이제 (여러 번) `factorial(..)`를 호출해도 유지되는 `cache`는 숨겨진 채로 남게 되지만 `factorial(..)`에서만 접근할 수 있다!

좋다, 하지만... 변수나 함수를 숨겨야 할 일이 있을 때마다 매번 `hideTheCache(..)`함수 스코프(와 이름)를 정의하는 것은 지루할 것이다. 특히 각 항목에 고유한 이름을 지정하여 이 함수와 이름이 충돌하지 않도록 해야 하기 때문이다. 으윽

| NOTE: |
| :--- |
| 동일한 입력으로 호출하는 것이 반복될 것으로 예상되는 경우, 성능을 최적화하기 위해 함수에서 계산한 결과를 캐싱하는 이 기법은 함수형 프로그래밍 세계에서는 매우 일반적이다. 이 기법은 "메모이제이션"으로 불리며 클로저(7창 참조)에 의존한다. 또한 메모리 사용량 문제가 있다. (부록 B의 "메모리에 대해서"에서 다룰 예정) 함수형 프로그래밍 라이브러리는 주로 함수의 메모이제이션에 최적화된 기능을 제공하며, 이 기능은 `hideTheCache(..)`를 대체한다. 메모이제이션은 지금 논의하고 있는 내용의 *스코프* (의도한 말장난!)를 벗어난다. 자세한 내용이 궁금하다면 *Functional-Light JavaScript* 책을 참조하라. |

이렇게 '변수를 숨기기 위한 목적만으로 스코프를 생성'해야 하는 상황이 발생할 때마다 고유한 이름을 붙여서 새로운 함수를 정의하는 대신 다음과 같은 함수 표현식을 사용하는 것이 더 나을 수 있다.

```js
var factorial = (function hideTheCache() {
    var cache = {};

    function factorial(x) {
        if (x < 2) return 1;
        if (!(x in cache)) {
            cache[x] = x * factorial(x - 1);
        }
        return cache[x];
    }

    return factorial;
})();

factorial(6);
// 720

factorial(7);
// 5040
```

잠깐! 이 함수는 여전히 `cache`를 숨기기 위한 스코프를 만드는 목적으로 함수를 사용하고 있으며 위 경우에 함수의 이름은 여전히 `hideTheCache`이다. 그러면 이 문제는 어떻게 해결될까?

"함수 이름 스코프"(3장)를 참조하여 `function` 표현식에서 이름 식별자가 어떻게 되는지 확인하라. `hideTheCache(..)`를 `function`' 선언 대신 `function` 표현식으로 정의했기 때문에 이 이름은 외부/전역 스코프가 아닌 자체 스코프, 기본적으로 `cache`와 동일한 스코프에 있다.

즉, 이렇게 함수 표현식을 사용한 부분마다 내부에서 함수의 이름을 동일하게 지정할 수 있으며, 충돌이 발생하지 않는다. 좀 더 적절하게, 숨기려는 것이 무엇이든 간에 각각의 함수에 의미론적으로 이름을 지정할 수 있고, 어떤 이름을 선택하든 프로그램의 다른 `function` 표현식의 스코프와 충돌할 것이라는 걱정은 하지 않아도 된다.

실제로 이름 전체를 *생략할 수도 있고*, 따라서 그 대신 "익명의 `function` 표현식"을 정의할 수 있다. 그러나 부록 A에서는 그러한 스코프 전용 함수에 대해서도 이름의 중요성에 대해 설명할 것이다.

### 함수 표현식을 바로 실행하기

위에서 다룬 팩토리얼 재귀 함수 코드에 지나치기 쉬운 중요한 부분이 있다. 바로 `function` 표현식의 마지막 줄에 있는 `})();` 부분이다.

`function` 표현식 전체를 `( .. )`로 감싸고 있다는 것에 주목하라. 마지막 부분에 두 번째로 `()` 괄호 한 쌍을 추가했는데 이 부분이 방금 `function` 표현식으로 정의한 함수를 호출하는 것이다. 이 때, 함수 표현식을 감싸는 첫 번째 `( .. )` 괄호가 꼭 필요한 것은 아니지만 가독성을 위해 사용한다.
 
즉, 위 코드는 즉시 실행되는 `function` 표현식을 정의하고 있다. 흔히 사용하는 이 패턴의 (매우 기발한) 이름은 바로 즉시 실행 함수 표현식<sub>Immediately Invoked Function Expression</sub>(IIFE)이다.

IIFE는 변수/함수를 숨기기 위해 새 스코프를 생성해야 할 때 유용하다. 단지 표현식이기 때문에, 표현식을 사용할 수 있는 JS 프로그램의 **모든** 위치에서 사용할 수 있다. IIFE에는 `hideTheCache()` 같은 이름을 붙여 줄 수도 있고 (좀 더 일반적으로) 익명으로 사용할 수도 있다. 또, 이 표현식은 독립적으로 사용할 수도 있고 다른 구문의 일부로 사용할 수도 있다. 위 코드에서는 `hideTheCache()`가 `factorial()` 함수 참조를 반환하는데 이것을 `=`을 통해 `factorial` 변수에 할당하고 있다.

IIFE를 독립적으로 사용하는 예제와 비교해보자:

```js
// 외부 스코프

(function(){
    // 안으로 숨긴 스코프
})();

// 이어지는 외부 스코프
```

앞서 살펴본 `hideTheCache()`에서는 외부를 둘러싸는 `(..)`가 겉모습을 위한 선택지에 불과했지만, IIFE를 독립적으로 사용하는 이 예제에서는 **필수적**인 것이 되었다. `function`을 구문이 아닌 표현식으로 구별해야 하기 때문이다. 물론, 일관성을 위해 IIFE `function`은 항상  `( .. )`로 감싸야 한다. 

| 비고: |
| :--- |
| 기술적인 관점으로 보면, `( .. )`로 감싸는 기법만이 JS 파서가 IIFE 내부의 `function`를 함수 표현식으로 취급하도록 하는 유일한 구문론적 방법은 아니다. 이 외의 방법은 부록 A에서 살펴볼 것이다. |

#### 함수 경계

IIFE를 사용하여 스코프를 정의할 때는 주변 코드에 따라서 의도하지 않은 결과가 나올 수 있으므로 주의해야 한다. IIFE는 완전히 함수이기 때문에, 함수의 경계가 특정한 구문/구성요소의 동작을 변경할 수 있다.

예를 들어, 코드의 특정 부분을 IIFE로 감싸게 되면 내부의 `return`의 의미는 달라질 수도 있다. 이 경우 `return`은 IIFE의 함수를 의미하기 때문이다. 화살표 함수로 작성하지 않은 IIFE도 `this` 키워드의 바인딩을 변경한다. (자세한 내용은 *Objects & Classs* 책을 참조하라) 그리고 `break`와 `continue`와 같은 키워드는 외부 루프나 블록을 제어하기 위해 IIFE 함수의 경계를 넘나들지 않는다.

따라서, 스코프로 감싸야 할 코드에 `return`, `this`, `break`, `continue` 등이 있다면 IIFE가 최선의 방법이 아닐 것이다. 이 경우 함수 대신 블록을 사용하여 스코프를 만들 수 있다.

## 블록으로 스코프 지정하기

이쯤 되면 식별자의 노출을 제한하기 위해 스코프를 생성하는 것의 장점을 이해할 수 있어야 한다.

지금까지는 (IIFE를 사용하여)  `function` 으로 스코프를 지정하는 법을 알아보았다. 지금부터는  `let` 선언과 중첩된 블록을 사용하는 방법을 살펴보자. 일반적으로 구문으로 사용한 `{ .. }` 중괄호 한 쌍은 블록 역할을 하지만, 그렇다고 해서 스코프 역할을 **항상 하는 것은 아니다.**

블록 스코프를 사용하는 선언을 포함(예를 들어, `let` 또는 `const`를 사용할 때)하기 위해 필요한 경우에만 스코프로 동작한다. 다음을 살펴보자:

```js
{
    // (아직) 스코프가 필요하지 않다.

    // ..

    // 이제, 이 블록은 스코프가 될 필요가 있다는 것을 알게 된다.
    let thisIsNowAScope = true;

    for (let i = 0; i < 5; i++) {
        // 여기도 개별적으로 활성화된 스코프이다.
        // 반복문
        if (i % 2 == 0) {
            // 여기는 스코프가 아닌 평범한 블록이다.
            console.log(i);
        }
    }
}
// 0 2 4
```

모든 `{ .. }` 중괄호가 블록을 생성하는 것은 아니다. (따라서, 스코프가 되지도 못한다.):

* 객체 리터럴에서 키-값 쌍을 명시하기 위해 `{ .. }` 중괄호를 사용하지만, 이러한 객체의 값에 스코프가 있는 건 **아니다**.

* `class`는 몸체를 정의하는 부분을 `{ .. }` 중괄호를 사용해 감싸지만, 블록이나 스코프는 아니다.

* `function`는 몸체를 `{ .. } ` 중괄호를 사용해 감싸지만, 기술적으로 블록이 아니라 함수의 몸체를 나타내는 단일 구문이다. 하지만,이것은 (함수) 스코프가 *맞다.*

* `switch`문에서 (`case`절을 감싸는) `{ .. }` 중괄호는 블록/스코프를 정의하지 않는다.

이렇게 블록이 아닌 경우를 제외하고, `{ .. }` 중괄호는 (`if` 또는 `for` 같은) 구문에 추가한 블록을 정의하거나 단독으로 사용할 수도 있다. 이전 코드에서 가장 바깥쪽 `{ .. }` 중괄호 쌍을 다시 보아라. 이런 종류(선언이 없어서 실제로는 스코프가 아닌 경우)의 명시적인 블록은 의미를 나타내는 용도로는 여전히 유용하지만, 사용해야 할 목적을 제공하진 않는다.

명시적이고 독립적인 `{ .. }` 블록은 이제까지 유효한 JS 문법이었지만, ES6의 `let`/`const` 이전에는 스코프가 될 수 없었기 때문에 거의 사용하지 않았다. 하지만 ES6 이후 이 방식은 조금씩 인기를 얻기 시작했다.

블록 스코프를 지원하는 대부분의 언어에서, 명시적인 블록 스코프는 여러개의 변수를 위해 작은 스코프를 생성하는데에 매우 자주 쓰이는 패턴이다. 따라서 POLE 원칙에 따라, JS에 이 패턴을 더 널리 수용해야 한다. 식별자의 노출을 최소한으로 좁히기 위해 (명시적) 블록 범위를 사용해야 한다. 식별자의 노출을 최소화하기 위해 (명시적) 블록 스코프를 사용하자.

명시적 블록 스코프는 (외부 블록이 스코프가 아니더라도) 다른 블록의 내부에서 유용할 수 있다.

예를 들어:

```js
if (somethingHappened) {
    // 이것은 블록이지만 스코프는 아니다.

    {
        // 이것은 블록이면서 명시적 스코프이다.
        let msg = somethingHappened.message();
        notifyOthers(msg);
    }

    // ..

    recoverFromSomething();
}
```

위의 예시처럼 `if`문의 **내부**에 위치한 `{ .. }` 중괄호 쌍은 훨씬 작은 명시적 블록 스코프이며 `msg`를 위해 존재한다. 그 변수가 `if` 블록 전체에서 필요하지 않기 때문이다. 대부분의 개발자는 `msg`의 블록 스코프를 `if` 블록에 두고 넘어간다. 그리고 엄밀히 말하자면, 신경써야 할 코드의 양이 많지 않을 때, 느낌대로 내린 결정일 것이다. 결국 코드가 많아질수록, 이런 과다한 노출 문제는 더욱 돋보이게 된다.

그렇다면 코드에 `{ .. }` 중괄호 한 쌍과 들여쓰기를 추가하는 것이 정말로 중요한걸까? 당신은 POLE 원칙을 지켜야 하고 언제나 (합리적인 범위 내에서) 각 변수에 대해 가장 작은 블록을 정의해야 한다고 생각한다. 그래서 위의 예시처럼 명시적인 블록 스코프를 사용하는 것이 좋다.

5장 "초기화되지 않는 변수들 (TDZ)"에서 다룬 TDZ 오류를 떠올려보자. TDZ 오류를 최소화하기 위해 `let`/`const` 선언을 사용하고 이 선언을 스코프의 가장 첫 부분에 두어야 한다고 제안한 바 있다.

만약 스코프의 중간 지점에 `let` 선언을 하려는 자신을 발견한다면, 먼저 "안돼! TDZ 경보!" 라고 생각하라. 만약 이 `let` 선언이 블록의 스코프의 상단에서 필요하지 않다면, 내부에 명시적인 블록 스코프를 사용하여 이 변수의 노출을 줄여야 한다.

명시적 블록 스코프를 사용하는 다른 예시:

```js
function getNextMonthStart(dateStr) {
    var nextMonth, year;

    {
        let curMonth;
        [ , year, curMonth ] = dateStr.match(
                /(\d{4})-(\d{2})-\d{2}/
            ) || [];
        nextMonth = (Number(curMonth) % 12) + 1;
    }

    if (nextMonth == 1) {
        year++;
    }

    return `${ year }-${
            String(nextMonth).padStart(2,"0")
        }-01`;
}
getNextMonthStart("2019-12-25");   // 2020-01-01
```

먼저 스코프와 해당하는 식별자를 알아보자:

1. 외부/전역 스코프에는 한 개의 식별자가 있다: `getNextMonthStart(..)` 함수

2. `getNextMonthStart(..)` 함수 스코프에는 세 개의 식별자가 있다: (매개변수)`dateStr`, `nextMonth`, 그리고 `year`

3. `{ .. }` 중괄호 한 쌍은 변수 하나를 포함하는 내부 블록 스코프를 정의하고 있다: `curMonth`

그렇다면 왜 `curMonth`을 `nextMonth`와 `year`와 같은 최상위 함수 스코프 대신 명시적 블록 스코프에 두었을까? 왜냐하면 `curMonth`는 처음 두 개의 구문에서만 필요하기 때문이다. 이런 변수를 함수 스코프에 둔다면 과다 노출인 셈이다.

이 예시 코드는 양이 적기 때문에 `curMonth`의 과다 노출로 인한 위험도 상당히 적은 편이다. 하지만 스코프의 노출을 최소화하는 방식을 기본적인 습관처럼 사용하면 POLE의 장점이 힘을 발휘한다. 사소한 경우에도 이 원칙을 지속적으로 적용한다면, 프로그램이 커지면서 더 많은 장점을 제공할 것이다.

조금 더 실질적인 예시를 살펴보자:

```js
function sortNamesByLength(names) {
    var buckets = [];

    for (let firstName of names) {
        if (buckets[firstName.length] == null) {
            buckets[firstName.length] = [];
        }
        buckets[firstName.length].push(firstName);
    }

    // 스코프를 좁히기 위한 블록
    {
        let sortedNames = [];

        for (let bucket of buckets) {
            if (bucket) {
                // 각 bucket을 사전순으로 정렬
                bucket.sort();

                // 정렬한 데이터를 실행 리스트에 추가
                sortedNames = [
                    ...sortedNames,
                    ...bucket
                ];
            }
        }

        return sortedNames;
    }
}

sortNamesByLength([
    "Sally",
    "Suzy",
    "Frank",
    "John",
    "Jennifer",
    "Scott"
]);
// [ "John", "Suzy", "Frank", "Sally",
//   "Scott", "Jennifer" ]
```

다섯 스코프에 걸쳐 여섯 개의 식별자가 있다. 이 모든 변수가 한 외부/전역 스코프에 존재할 수 있을까? 기술적으로 가능하다. 모두 고유한 이름이 지정되어 이름 충돌이 없기 때문이다. 하지만 이런 경우, 코드의 구성을 매우 부실하게 하여 혼란이나 버그를 유발할 수 있다.

필요에 따라 한 스코프를 내부의 중첩 스코프로 여러 개로 나누자. 프로그램이 의도한대로 동작할 수 있는 가장 안쪽의 스코프에서 각 변수를 정의하게 된다.

최상위 함수 스코프에서 `sortedNames`를 정의할 수도 있었지만, 이 변수는 함수의 후반부에서만 필요하다. 상위 스코프에서 변수의 과다 노출을 막기 위해, POLE 원칙을 따라 내부의 명시적 블록 스코프를 지정했다.

### `var` *그리고* `let`

다음으로 `var buckets`라고 선언한 부분을 살펴보자. 이 변수를 (마지막 `return`문을 제외한) 함수 전체에서 사용하고 있다. 함수의 전체(또는 대부분)에 걸쳐 필요한 변수는 용도가 명확하게 보이도록 선언해야 한다.

| 비고: |
| :--- |
| 매개변수 `names`는 함수 전체에서 사용하고 있진 않지만 스코프를 제한할 수 있는 방법이 없기 때문에 위 방법과는 상관없이 함수 전체에서의 선언으로 동작한다. |

그렇다면 왜 `let` 대신 `var`로 `buckets` 변수를 선언했을까? `var`를 선택한 의미적인 이유, 기술적인 이유가 둘 다 있다.

문체적으로, `var`는 JS의 초창기부터 항상 "함수 전체에 속하는 변수"를 나타냈다. 1장 "Lexical Scope"에서 주정한 것과 같이, `var`는 어디에 나타도 가장 가까운 함수 스코프 내부에 속하게 된다. 블록 안에서 `var`가 나와도 마찬가지다.

```js
function diff(x,y) {
    if (x > y) {
        var tmp = x;    // `tmp`은 함수 스코프에 있다.
        x = y;
        y = tmp;
    }

    return y - x;
}
```

`var`는 블록 안에 있지만, 이 선언은 블록 스코프가 아닌 함수 스코프(`diff(..)`)에 속한다.

블록 내에서 `var`로 선언할 수 있지만(그래도 함수 스코프에 속하게 됨) 몇 가지 구체적인 경우(부록 A에서 설명)를 제외하고는 이런 방식을 사용하지 않는게 좋다. 그렇지 않으면 `var`는 함수의 최상위 스코프에서 사용해야 한다.

같은 위치에서 `let`을 사용하면 어떨까? `var`는 `let`과 시각적으로 구별될 뿐만 아니라 "이 변수는 함수 스코프에 속한다."란 의미를 갖기 때문이다. 함수 내부의 최상위 스코프(그리고 특히 함수의 초반부가 아닌 위치)에서 `let`을 사용하면서 같은 블록 내의 다른 선언에도 모두 `let`를 사용한다면 함수 스코프 선언과의 차이점에 대해 시각적으로 주의를 끌지 못할 것이다. 

다시말해서 `var`은 `let`보다 더 함수 스코프로 지정되었다는 의미를 더 잘 전달한다고 느낄 수 있다. 그리고 `let` 또한 `var`로 충분히 설명할 수 없는 블록 스코프에 속한다는 의미를 더 잘 전달(하고 달성)할 수 있게 된다. 프로그램이 함수 스코프 변수와 블록 스코프 변수를 모두 필요로 하는 한, 가장 합리적이면서 가독성이 좋은 방법은 `var` *그리고* `let`을 각각의 목적에 맞게 함께 사용하는 것이다.

특정 상황에서 `var` 또는 `let`을 구분해 사용하게 되는 의미와 실행 측면에서 또 다른 이유가 있다. 부록 A에서 `var` *그리고* `let`의 자세한 내용을 더 살펴볼 것이다.

| 주의: |
| :--- |
| `var` *그리고* `let`을 동시에 사용하는 방법은 분명히 논란의 여지가 있고 다수의 의견과도 엇갈린다. "var는 고장났기 때문에 let으로 고쳐라"라든지 "var를 사용하지 말고 let으로 대체하라"하는 주장을 훨씬 더 흔히 들을 수 있다. 이런 의견도 타당하지만 위에서 주장했던 내용과 마찬가지로 단지 의견일 뿐이다. `var`는 실제로 고장이났다거나 사라지게 될 것은 아니고 JS 초기부터 그래왔던 것처럼 앞으로도 JS가 있는 한 계속 작동할 것이다.

### `let`이 있어야할 곳은?

`var`를 (거의) 최상위 함수 스코프에서만 사용하라는 말은 대부분의 다른 경우에는 `let`으로 선언해야 한다는 것을 의미한다. 하지만 이 조언대로 하려고 해도 여전히 프로그램의 각 선언을 어떤 스코프에 속하도록 배치할지 고민하게 될 것이다.

POLE가 이미 위와 같은 고민에 도움을 주고 있긴 하지만, 좀 더 명확하게 설명해보자. 위와 같은 문제를 해결하는 방법은 어떤 키워드를 사용할지 결정하는 것이 아니다. 정확한 방법은 "이 변수에게 충분한 최소한의 스코프 노출은 무엇입니까?"란 질문을 던지는 것이다.

이 질문의 답을 찾으면, 그 변수가 블록 스코프에 속하는지 함수 스코프에 속하는지 알게 될 것이다. 처음에 변수를 블록 스코프로 지정해두었다가 함수 스코프로 상향 조정해야하는 상황이 올 때, 해당 변수의 선언 위치뿐만 아니라 사용된 선언자 키워드까지 같이 수정하면 된다. 이런 식으로 의사결정 과정을 진행해야 한다.

선언이 블록 스코프에 속하면 `let`을 사용하라. 함수 스코프에 속하면 `var`(다시 말하지만, 필자의 의견이다)를 사용하라.

하지만 이런 결정을 시각화하는 또 다른 방법은 ES6 이전의 프로그램을 고려해보는 것이다. 예를 들어, 앞에서 나왔던 `diff(..)`을 다시 살펴보자:

```js
function diff(x,y) {
    var tmp;

    if (x > y) {
        tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}
```

이 버전의 `diff(..)`에서는 `tmp`를 정확히 함수 스코프 내에 선언한다. 이것이 `tmp`에게 적합할까? 아니라고 할 수 있다. `tmp`은 오직 일부 구문에서만 필요하다. `return` 구문 에서도 필요 없다. 그러므로 블록 스코프를 지정해주어야 한다.

ES6 이전에는 `let`이 없어서 블록 스코프를 *실제로* 지정할 수 없었다. 하지만 이런 의도를 알리는 차선책을 생각해볼 수 있다:

```js
function diff(x,y) {
    if (x > y) {
        // `tmp`는 여전히 함수 스코프에 속한다.
        // 하지만 여기에 배치했다는 것은
        // 의미론적으로 블록 스코프에 속한다는 뜻을 나타낸다.
        var tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}
```

`tmp`에 대한 `var` 선언을 `if` 구문 내부에 두면, `tmp`가 그 블록에 속한다는 것을 코드를 읽는 사람에게 전달할 수 있다. JS가 이 스코프에 대해서 강제하지 않지만, 그 의미론적인 신호는 코드를 읽는 사람에게 장점을 발휘한다.

이런 관점으로 보면, 이런 종류의 블록 안에 있는 그 어떤 `var`라도 찾아내  `let`으로 교체해서 이미 전달하고 있는 의미론적인 신호를 강제할 수 있다. 그것이 `let`의 적절한 사용법이다.

역사적으로 `var` 를 기초로 두고 있었지만 이제는 `let`을 항상 사용해야 하는 또 다른 예는 `for` 반복문이다:

```js
for (var i = 0; i < 5; i++) {
    // 무언가 처리한다.
}
```

이러한 반복문을 정의하는 위치에 관계없이, 기본적으로 `i`는 항상 반복문 안에서만 사용해야 하며, 이 경우 POLE는 `var` 대신 `let`으로 선언해야 하도록 지시한다:

```js
for (let i = 0; i < 5; i++) {
    // 무언가 처리한다.
}
```

이런 식으로 `var`를 `let`으로 교체하면 코드가 "깨질" 수 있는 거의 유일한 경우는 다음과 같이 반복문의 바깥이나 뒤에서 반복자(`i`)에 접근하는 경우이다.

```js
for (var i = 0; i < 5; i++) {
    if (checkValue(i)) {
        break;
    }
}

if (i < 5) {
    console.log("반복문이 일찍 멈췄다!");
}
```

이런 사용 패턴은 매우 드물게 보이는 것이 아니지만, 대부분은 코드 구조가 좋지 않다고 느낀다. 바람직한 방법은 목적에 맞는 다른 외부 스코프의 변수를 사용하는 것이다.

```js
var lastI;

for (let i = 0; i < 5; i++) {
    lastI = i;
    if (checkValue(i)) {
        break;
    }
}

if (lastI < 5) {
    console.log("반복문이 일찍 멈췄다!");
}
```

전체 스코프에 걸쳐 `lastI`가 필요하기 때문에  `var`로 선언했다. `i`는 (각) 반복문을 반복할 때에만 필요하므로 `let`으로 선언했다.

### Catch는 무엇인가?

지금까지 `var`와 매개변수는 함수 스코프에 속하고, `let`/`const`는 블록 스코프에 속하는 선언임을 확인했다. 그런데, 여기서 한 가지 예외가 있다. 바로 `catch` 구문이다.

1999년 ES3으로 `try...catch`가 도입된 이후 `catch` 구문은 (거의 알려지지 않은) 추가적인 블록 스코프를 지정하는 선언 기능을 갖고 있었다:

```js
try {
    doesntExist();
}
catch (err) {
    console.log(err);
    // ReferenceError: 'doesntExist' is not defined
    // ^^^^ message printed from the caught exception

    let onlyHere = true;
    var outerVariable = true;
}

console.log(outerVariable);     // true

console.log(err);
// ReferenceError: 'err' is not defined
// ^^^^ this is another thrown (uncaught) exception
```

`catch`문에서 선언한 `err` 변수는 해당 블록의 (블록) 스코프에 속하게 된다. 이 `catch`문의 블록에서 `let`과 같은 블록 스코프 선언을 사용할 수 있다. 하지만, 이 블록에서도 `var` 선언은 여전히 외부의 함수/전역 스코프에 속하게 된다.

(이 글을 작성한 시점에서 가장 최근인) ES2019에서 `catch`문은 변수 선언을 생략할 수 있도록 바뀌었다. 선언을 생략하면 `catch` 블록은 더 이상 (기본적으로) 스코프로 동작하지 않는다. 여전히 블록이긴 해도 말이다.

그래서 *오류가 발생한* 상태에는 (안전하게 복구할 수 있도록) 대응해야 하지만, 오류 값 자체는 중요하지 않을 때, `catch`의 변수 선언을 생략할 수 있다:

```js
try {
    doOptionOne();
}
catch {   // catch 선언을 생략함
    doOptionTwoInstead();
}
```

위 내용은 상당히 일반적인 사용 사례를 고려하여, 약간이지만 적절하게 문법을 단순화한 것이다. 그리고 불필요한 스코프를 줄이는데에도 약간이나마 더 효과적일 수 있다.

## 블록에서의 함수 선언<sub>Function Declarations in Blocks</sub> (FiB)

`let`이나 `const`를 사용하면 블록 스코프에 속하고 `var`는 함수 스코프에 속한다는 것을 알아보았다. 그렇다면 블록 안에서 직접 `function`선언을 사용하면 어떻게 될까? 이런 함수를 "FiB"라고 한다.

일반적으로 `function` 선언을 `var` 선언처럼 생각하기도 한다.  그렇다면 `var` 처럼 함수 스코프로 지정이 될까?

아니기도 하고 맞기도 하다. 약간 혼란스러운데, 예제를 자세히 살펴보자:

```js
if (false) {
    function ask() {
        console.log("Does this run?");
    }
}
ask();
```

위 코드가 어떻게 동작할 것으로 예상하는가? 다음 세 가지 결과를 생각해볼 수 있다:

1. `ask()`를 호출하면 실패하고 `ReferenceError` 예외가 발생할 것이다. `ask` 식별자가 `if` 블록 스코프에 속하므로 외부/전역 스코프에서는 사용할 수 없기 때문이다.

2. `ask()`를 호출하면 실패하고 `TypeError` 예외가 발생할 것이다. `ask` 식별자가 존재하지만 (`if` 문 내부는 실행하지 않으므로) `undefined` 이라서 호출할 수 있는 함수가 아니기 때문이다.

3. `ask()`를 호출하면 문제 없이 동작하여 "Does it run?" 문구를 출력할 것이다.

여기에 혼란스러운 부분이 있는데, 위 코드를 어떤 JS 환경에서 실행하는지에 따라 다른 결과가 나올 수 있기 때문이다! 이런 경우가 바로 기존 동작에서 예측 가능했던 결과를 내지 못하게 하는 이상한 영역 중 하나이다.

JS 명세에 따르면 블록 내부의 `function` 선언은 블록 스코프에 속하므로 (1)과 같은 결과가 나와야 한다. 그러나 대부분 브라우저를 기반으로 하는 JS 엔진(Chrome에서 나왔지만 Node에서도 사용하는 v8를 포함)은  (2)와 같이 동작한다. 식별자는 `if` 블록의 외부 스코프로 지정되지만 함수 값이 자동으로 초기화되지는 않으므로 `undefined`를 유지하게 된다.

브라우저 JS 엔진이 명세에 맞지 않는 동작을 허용하는 이유는 무엇일까? 이 엔진은 이미 ES6에서 블록 스코프가 나오기 이전에 이미 FiB에 대한 동작을 정의하고 있었기 때문이다. 그래서, 명세에 따른 방식으로 동작을 변경할 경우, 기존의 웹사이트 JS 코드의 동작에 문제가 생길 수 있다는 우려가 있었다. 이렇게, JS 명세의 부록 B에서 예외가 만들어졌고, 이 예외는 브라우저 JS 엔진(만)의 이런 동작 차이를 허용하고 있다.

| 비고: |
| :--- |
| 일반적으로 Node는 주로 서버에서 실행하므로 브라우저 JS 환경으로 분류하지 않는다. 하지만 Node의 v8 엔진은 Chrome(그리고 Edge)에서도 사용하고 있다. v8를 브라우저 JS 엔진으로 사용하기 때문에 부록 B 예외를 적용하게 되었으며, 브라우저 예외가 Node까지 확장된다는 것을 의미한다. |

`function` 선언을 블록 내부에 배치하는 가장 일반적인 사용법 중 하나는 어떤 환경인지에 따라 (`if..else`문을 이용하여) 함수를 조건부로 정의하는 것이다. 예를 들어:

```js
if (typeof Array.isArray != "undefined") {
    function isArray(a) {
        return Array.isArray(a);
    }
}
else {
    function isArray(a) {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    }
}
```

성능상의 이유로 이런 식으로 코드의 구조를 잡는 것이 매력적일 것이다. `isArray(..)`를 정의하고 내부에 `if`문을 넣어 실행할 때마다 매번 불필요하게 조건식을 검사하는 대신, `typeof Array.isArray` 검사를 한 번만 수행할 수 있기 때문이다.

| 주의: |
| :--- |
| FiB 동작 차이로 인한 위험성 외에도, 조건적으로 함수를 정의하는 경우의 또 다른 문제점은 바로 디버깅하기 어렵다는 것이다. `isArray(..)` 함수에 버그가 있다는 걸 알게 되면, 가장 먼저 어떤 `isArray(..)`의 구현을 실제로 실행하고 있는지 파악해야 한다. 때때로, 이런 버그는 초기 조건식의 오류로 잘못된 구현을 적용하게 되어 발생하기도 한다! 함수를 여러 버전으로 정의하게 되면, 그 프로그램을 파악하고 유지 보수하기 어렵다. |

상기한 코드 외에도 FiB의 여러가지 예외 동작이 더 숨어 있다. 다양한 브라우저와 브라우저 외 JS 환경(브라우저 기반이 아닌 JS 엔진)에서 FiB는 다양하게 동작할 것이다. 예를 들어:

```js
if (true) {
    function ask() {
        console.log("Am I called?");
    }
}

if (true) {
    function ask() {
        console.log("Or what about me?");
    }
}

for (let i = 0; i < 5; i++) {
    function ask() {
        console.log("Or is it one of these?");
    }
}

ask();

function ask() {
    console.log("Wait, maybe, it's this one?");
}
```

5장의 "언제 변수를 사용할 수 있을까?"에서 설명한 함수 호이스팅을 상기하라. "Wait, maybe..." 메시지를 출력하는 위 코드의 마지막 `ask()`가 `ask()`를 호출하기 전 위치로 호이스팅 될 것이다. 그렇다면 같은 이름으로 하는 마지막 함수 선언이므로 마지막 `ask()`로 실행하게 될까? 아쉽지만 아니다.

이런 예외 동작을 모두 정리한다거나 왜 각자마다 특정한 방식으로 동작하는지 설명하려고 하는 것은 아니다. 이런 정보는 그저 불가사의하고 사소한 레거시라고 생각한다.

FiB에 대해 가장 중요한 것은, 코드가 모든 상황에서 언제나 예측 가능한 방식으로 동작하도록 하려면 어떻게 해야할지 아는 것이다.

일반적으로, FiB의 예외 상황을 피하는 가장 실용적인 방법은 바로 FiB를 사용하지 않는 것이다. 즉, 어떤 블록 내부에라도 `function` 선언을 직접 사용하지 말아라. `function` 선언은 항상 함수의 최상위 스코프(또는 전역 스코프)에 해야 한다.

그래서 상기한 `if..else` 예제에서는, 가능한한 함수를 조건부로 정의하지 않는 것을 권장한다. 그렇다. 성능상의 이득은 줄어들지만 이런 방식이 조금 더 나은 접근법이다:

```js
function isArray(a) {
    if (typeof Array.isArray != "undefined") {
        return Array.isArray(a);
    }
    else {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    }
}
```

만약 성능 저하가 애플리케이션에서 가장 치명적인 문제가 된다면, 다음과 같이 접근해볼 것을 제안한다:

```js
var isArray = function isArray(a) {
    return Array.isArray(a);
};

// 필요하다면, 정의를 오버라이드한다.
if (typeof Array.isArray == "undefined") {
    isArray = function isArray(a) {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    };
}
```

여기서 `if`문 내부에 함수를 선언한 것이 아니라 `function` **표현식**을 사용했다는 것에 주목하라. `function` 표현식을 블록 내부에 배치하는 것은 완벽하고 유효한 방법이다. FiB에 대해 이야기 하고 있는 내용이 바로 블록 내부의 `function` **선언**을 피하는 것이기 때문이다.

프로그램이 올바르게 작동하더라도, FiB 방식을 코드에 적용하여 얻을 수 있는 약간의 이점은 다른 개발자가 느낄 혼란으로 인한 잠재적인 위험이나 다른 JS 환경에서 실행하는 방식으로 인한 동작 차이에 비하면 너무나 작다.

FiB는 그럴 가치가 없으며 반드시 피해야 한다.

## 마무리

프로그래밍 언어에서 렉시컬 스코프 지정의 핵심은 운영적인 관점이나 코드의 의미를 통한 소통의 관점 모두를 고려하여 적절하게 프로그램의 변수를 구성할 수 있도록 하는 것이다.

그리고 가장 중요한 조직화 기법중 하나는 변수가 불필요한 스코프까지 과다하게 노출되지 않도록 하는 것(POLE)이다. 블록 스코프 지정의 장점을 이전보다 더 깊게 이해하길 바란다.

지금쯤이면 렉시컬 스코프에 대한 이해와 함께 훨씬 더 단단한 기반위에 서 있는 것처럼 느낄 수 있을 것이다. 이것을 바탕으로 다음 장에서는 클로저라는 중요한 주제로 넘어갈 것이다.

[^POLP]: *Principle of Least Privilege*, https://en.wikipedia.org/wiki/Principle_of_least_privilege, 2020년 3월 3일.
